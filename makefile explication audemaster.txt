NAME = libft.a #Création d'une variable NAME qui porte le nom du dossier archive(pouvant contenir plusieurs fichier objets(.o))


OBJ_PATH = ./objs/ #OBJ_PATH va prendre la valeur ./objs/
** Dans l'idee c'est bon, mais pour la libft tu n'en n'auras pas besoin - garde l'astuce pour la suite du parcours **


SRC_NAME = {programmes		 	#On crée une variable qui va chercher dans le dossier où est le makefile tous les fichiers nommés.
	    ciblés	}		#On peut ajouter la commande SRC=$(addprefix ft_, $(addsuffix .c,) au tout début afin de marquer seulement le nom du programme et rendre plus lisible le programme.

OBJ_NAME = $(SRC_NAME:.c=.o) #On convertit tout les fichier en .c en fichier objet(.o)

# Files

OBJ = $(addprefix $(OBJ_PATH), $(OBJ_NAME)) #Tout les fichier qui sont attribué dans OBJ_NAME se voient ajouté devant leur nom de fichier OBJ_PATH (./objs/)
** T'en n'auras pas besoin pour la libft -> si tu crees un repertoire qui ne t'es pas demande et que tu oublies de le supprimer tu vas te faire degommer par la moulinette **


CFLAGS = -Wall -Wextra -Werror 	#On crée la variable CFLAGS contenant -Wall -Wextra -Werror afin de pouvoir compiler avec ces flags

CC = gcc $(CFLAGS) 		#On crée la variable CC avec le compilateur gcc afin de pouvoir compilé quand on appliquera les règles du makefile
** Ici ce n'est pas faux, mais on le fait rarement comme ca, regarde du cote des regles implicites du Makefile pour le pourquoi du comment, CC peut etre generee implicitement par make en fait et tu n'auras jamais de flag avec, je te conseille de dissocier les deux macros, tu pourras les accoler ensemble dans la regle de compilation **

# Rules

all: $(NAME)

$(NAME): $(OBJ)
	@echo "Creation of $(NAME)... \n" 	#Envoi du message annonçant le début de la création du dossier archive
	@ar rc $(NAME) $(OBJ) 			#On crée une archive (c) nommée NAME(libft.a) et archivé (r) https://linux.die.net/man/1/ar
	@ranlib $(NAME) 			#On indexe l'archive grace a ranlib
	@echo "(NAME) created\n" 		#Message pour indiquer que l'archive fut faite
** Si tu fais `ar rcs $(NAME) $(OBJ)` ca revient au meme que de faire `@ar rc $(NAME) $(OBJ) @ranlib $(NAME)`

$(OBJ_PATH)%.o: %.c ** Et ta variable $(OBJ_NAME) elle sert a quoi si tu fais ca ? **

	@$(CC) -o $@ -c $<

clean:
	@echo "Removal of .o files of $(NAME) ..." 	#Envoi du message annonçant la suppression des fichiers archives
	@rm -f $(OBJ) Tous les fichiers 		#Suppression forcée(-f) de tous les fichiers contenus dans OBJ
	@rmdir $(OBJ_PATH) 2> /dev/null || true		** rmdir -> peut etre remplacer par rm -rf **
	@echo "Files .o deleted\n"			#Envoi du message annonçant que la suppression est effectuée
** Ici pour ne pas laisser de repertoire non demandes par la moulinette, tu devrais faire `make clean` dans ta regle $(NAME), a la suite **

fclean: clean						#On lance la règle clean ** -> la regle clean est un pre-requis a la regle fclean, c-a-d, pas de clean, pas de fclean **
	@echo "Removal of $(NAME)..."			#Envoi du message annonçant la supression du fichier NAME(libft.a)
	@rm -f $(NAME)					#Suppression forcée(-f) du dossier NAME(libft.a)
	@echo "Binary $(NAME) deleted\n"		#Envoi du message annonçant que la suppression est faite

re: fclean all

.PHONY: all, clean, fclean, re				#La Commande PHONY permet aux règles de fonctionner sans erreur (c'est dû au fonctionnement du makefile( https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html )
** La regle .PHONY te permet d'indiquer des noms de cible qui ne sont pas des noms de fichiers, en les mettant dans .PHONY ca empeche le relinkage, c'est ce qu'il faut faire qd ils nous disent en consignes "pas de relink", mettre la-dite cible en .PHONY. L'ordre n'a pas trop d'importance mais par convention, au va placer .PHONY avant la regle all, histoire d'etre certain que c'est pris en compte et qu'il n'y ait pas de relink inopine **

norme:
	norminette $(SRC)				#On lance la norminette
	norminette $(INC_PATH)*.h			#On lance la norminette pour les fichier .h ** Attention ta variable $(INC_PATH) est inexistante **

** Par convention, quasiment toutes les commandes shell que tu indiques, on les passe par macro, comme avec CC. Du genre `ar -rcs` devient $(AR) ou `rm -rf` devient $(RM) **
** Sinon c'est pas trop mal, pour une libft ca devrait passer **